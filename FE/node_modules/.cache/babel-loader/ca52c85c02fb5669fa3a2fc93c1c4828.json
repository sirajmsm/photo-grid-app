{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { isMouseEnabled } from \"./mouse-enabled\";\nvar initialState = {\n  time: Date.now(),\n  xy: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  direction: [0, 0],\n  initialDirection: [0, 0],\n  local: [0, 0],\n  lastLocal: [0, 0],\n  velocity: 0,\n  distance: 0\n};\nvar defaultConfig = {\n  enableMouse: true\n};\nvar grantedTouch = null;\nexport function useGestureResponder(options, config) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  var state = React.useRef(initialState);\n\n  var _a = tslib_1.__assign({}, defaultConfig, config),\n      uid = _a.uid,\n      enableMouse = _a.enableMouse;\n\n  var id = React.useRef(uid || Math.random());\n  var pressed = React.useRef(false); // update our callbacks when they change\n\n  var callbackRefs = React.useRef(options);\n  React.useEffect(function () {\n    callbackRefs.current = options;\n  }, [options]);\n  /**\n   * Attempt to claim the active touch\n   */\n\n  function claimTouch(e) {\n    if (grantedTouch && grantedTouch.onTerminationRequest(e)) {\n      grantedTouch.onTerminate(e);\n      grantedTouch = null;\n    }\n\n    attemptGrant(e);\n  }\n  /**\n   * Attempt to claim the active touch\n   * @param e\n   */\n\n\n  function attemptGrant(e) {\n    // if a touch is already active we won't register\n    if (grantedTouch) {\n      return;\n    }\n\n    grantedTouch = {\n      id: id.current,\n      onTerminate: onTerminate,\n      onTerminationRequest: onTerminationRequest\n    };\n    onGrant(e);\n  }\n\n  function bindGlobalMouseEvents() {\n    window.addEventListener(\"mousemove\", handleMoveMouse, false);\n    window.addEventListener(\"mousemove\", handleMoveMouseCapture, true);\n    window.addEventListener(\"mouseup\", handleEndMouse);\n  }\n\n  function unbindGlobalMouseEvents() {\n    window.removeEventListener(\"mousemove\", handleMoveMouse, false);\n    window.removeEventListener(\"mousemove\", handleMoveMouseCapture, true);\n    window.removeEventListener(\"mouseup\", handleEndMouse);\n  }\n\n  function handleStartCapture(e) {\n    updateStartState(e);\n    pressed.current = true;\n    var granted = onStartShouldSetCapture(e);\n\n    if (granted) {\n      attemptGrant(e);\n    }\n  }\n\n  function handleStart(e) {\n    updateStartState(e);\n    pressed.current = true;\n    bindGlobalMouseEvents();\n    var granted = onStartShouldSet(e);\n\n    if (granted) {\n      attemptGrant(e);\n    }\n  }\n\n  function isGrantedTouch() {\n    return grantedTouch && grantedTouch.id === id.current;\n  }\n  /**\n   * Handle touchend / mouseup events\n   * @param e\n   */\n\n\n  function handleEnd(e) {\n    pressed.current = false;\n    unbindGlobalMouseEvents();\n\n    if (!isGrantedTouch()) {\n      return;\n    } // remove touch\n\n\n    grantedTouch = null;\n    onRelease(e);\n  }\n  /**\n   * Handle touchmove / mousemove capture events\n   * @param e\n   */\n\n\n  function handleMoveCapture(e) {\n    updateMoveState(e);\n\n    if (isGrantedTouch()) {\n      return;\n    }\n\n    if (onMoveShouldSetCapture(e)) {\n      claimTouch(e);\n    }\n  }\n  /**\n   * Handle touchmove / mousemove events\n   * @param e\n   */\n\n\n  function handleMove(e) {\n    if (isGrantedTouch()) {\n      onMove(e);\n      return;\n    }\n\n    if (onMoveShouldSet(e)) {\n      claimTouch(e);\n    }\n  }\n  /**\n   * When our gesture starts, should we become the responder?\n   */\n\n\n  function onStartShouldSet(e) {\n    return callbackRefs.current.onStartShouldSet ? callbackRefs.current.onStartShouldSet(state.current, e) : false;\n  }\n  /**\n   * Same as onStartShouldSet, except using capture.\n   */\n\n\n  function onStartShouldSetCapture(e) {\n    return callbackRefs.current.onStartShouldSetCapture ? callbackRefs.current.onStartShouldSetCapture(state.current, e) : false;\n  }\n  /**\n   * When our gesture moves, should we become the responder?\n   */\n\n\n  function onMoveShouldSet(e) {\n    return callbackRefs.current.onMoveShouldSet ? callbackRefs.current.onMoveShouldSet(state.current, e) : false;\n  }\n  /**\n   * Same as onMoveShouldSet, but using capture instead\n   * of bubbling.\n   */\n\n\n  function onMoveShouldSetCapture(e) {\n    return callbackRefs.current.onMoveShouldSetCapture ? callbackRefs.current.onMoveShouldSetCapture(state.current, e) : false;\n  }\n  /**\n   * The view is responding to gestures. Typically corresponds\n   * with mousedown or touchstart.\n   * @param e\n   */\n\n\n  function onGrant(e) {\n    if (callbackRefs.current.onGrant) {\n      callbackRefs.current.onGrant(state.current, e);\n    }\n  }\n  /**\n   * Update our kinematics for start events\n   * @param e\n   */\n\n\n  function updateStartState(e) {\n    var _a = e.touches && e.touches[0] ? e.touches[0] : e,\n        pageX = _a.pageX,\n        pageY = _a.pageY;\n\n    var s = state.current;\n    state.current = tslib_1.__assign({}, initialState, {\n      lastLocal: s.lastLocal || initialState.lastLocal,\n      xy: [pageX, pageY],\n      initial: [pageX, pageY],\n      previous: [pageX, pageY],\n      time: Date.now()\n    });\n  }\n  /**\n   * Update our kinematics when moving\n   * @param e\n   */\n\n\n  function updateMoveState(e) {\n    var _a = e.touches && e.touches[0] ? e.touches[0] : e,\n        pageX = _a.pageX,\n        pageY = _a.pageY;\n\n    var s = state.current;\n    var time = Date.now();\n    var x_dist = pageX - s.xy[0];\n    var y_dist = pageY - s.xy[1];\n    var delta_x = pageX - s.initial[0];\n    var delta_y = pageY - s.initial[1];\n    var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);\n    var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n    var scaler = 1 / (len || 1);\n    var velocity = len / (time - s.time);\n    var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0 ? s.initialDirection : [delta_x * scaler, delta_y * scaler];\n    state.current = tslib_1.__assign({}, state.current, {\n      time: time,\n      xy: [pageX, pageY],\n      initialDirection: initialDirection,\n      delta: [delta_x, delta_y],\n      local: [s.lastLocal[0] + pageX - s.initial[0], s.lastLocal[1] + pageY - s.initial[1]],\n      velocity: time - s.time === 0 ? s.velocity : velocity,\n      distance: distance,\n      direction: [x_dist * scaler, y_dist * scaler],\n      previous: s.xy\n    });\n  }\n  /**\n   * The user is moving their touch / mouse.\n   * @param e\n   */\n\n\n  function onMove(e) {\n    if (pressed.current && callbackRefs.current.onMove) {\n      callbackRefs.current.onMove(state.current, e);\n    }\n  }\n  /**\n   * The responder has been released. Typically mouse-up or\n   * touchend events.\n   * @param e\n   */\n\n\n  function onRelease(e) {\n    var s = state.current;\n    state.current = tslib_1.__assign({}, state.current, {\n      lastLocal: s.local\n    });\n\n    if (callbackRefs.current.onRelease) {\n      callbackRefs.current.onRelease(state.current, e);\n    }\n\n    grantedTouch = null;\n  }\n  /**\n   * Check with the current responder to see if it can\n   * be terminated. This is currently only triggered when returns true\n   * from onMoveShouldSet. I can't really envision much of a\n   * use-case for doing this with a standard onStartShouldSet.\n   *\n   * By default, returns true.\n   */\n\n\n  function onTerminationRequest(e) {\n    return callbackRefs.current.onTerminationRequest ? callbackRefs.current.onTerminationRequest(state.current, e) : true;\n  }\n  /**\n   * The responder has been taken by another view\n   */\n\n\n  function onTerminate(e) {\n    var s = state.current;\n    state.current = tslib_1.__assign({}, state.current, {\n      lastLocal: s.local\n    });\n\n    if (callbackRefs.current.onTerminate) {\n      callbackRefs.current.onTerminate(state.current, e);\n    }\n  }\n  /**\n   * Use window mousemove events instead of binding to the\n   * element itself to better emulate how touchmove works.\n   */\n\n\n  function handleMoveMouse(e) {\n    if (isMouseEnabled()) {\n      handleMove(e);\n    }\n  }\n\n  function handleMoveMouseCapture(e) {\n    if (isMouseEnabled()) {\n      handleMoveCapture(e);\n    }\n  }\n\n  function handleEndMouse(e) {\n    if (isMouseEnabled()) {\n      handleEnd(e);\n    }\n  }\n\n  React.useEffect(function () {\n    return unbindGlobalMouseEvents;\n  }, []);\n  /**\n   * Imperatively terminate the current responder\n   */\n\n  function terminateCurrentResponder() {\n    if (grantedTouch) {\n      grantedTouch.onTerminate();\n      grantedTouch = null;\n    }\n  }\n  /**\n   * A getter for returning the current\n   * responder, if it exists\n   */\n\n\n  function getCurrentResponder() {\n    return grantedTouch;\n  }\n  /**\n   * Required touch / mouse events\n   */\n\n\n  var touchEvents = {\n    onTouchStart: handleStart,\n    onTouchEnd: handleEnd,\n    onTouchMove: handleMove,\n    onTouchStartCapture: handleStartCapture,\n    onTouchMoveCapture: handleMoveCapture\n  };\n  var mouseEvents = enableMouse ? {\n    onMouseDown: function (e) {\n      if (isMouseEnabled()) {\n        handleStart(e);\n      }\n    },\n    onMouseDownCapture: function (e) {\n      if (isMouseEnabled()) {\n        handleStartCapture(e);\n      }\n    }\n  } : {};\n  return {\n    bind: tslib_1.__assign({}, touchEvents, mouseEvents),\n    terminateCurrentResponder: terminateCurrentResponder,\n    getCurrentResponder: getCurrentResponder\n  };\n}","map":{"version":3,"sources":["/Users/sirajmsm/Desktop/gapstarpro/photo-grid-app/FE/node_modules/react-gesture-responder/esm/index.js"],"names":["tslib_1","React","isMouseEnabled","initialState","time","Date","now","xy","delta","initial","previous","direction","initialDirection","local","lastLocal","velocity","distance","defaultConfig","enableMouse","grantedTouch","useGestureResponder","options","config","state","useRef","_a","__assign","uid","id","Math","random","pressed","callbackRefs","useEffect","current","claimTouch","e","onTerminationRequest","onTerminate","attemptGrant","onGrant","bindGlobalMouseEvents","window","addEventListener","handleMoveMouse","handleMoveMouseCapture","handleEndMouse","unbindGlobalMouseEvents","removeEventListener","handleStartCapture","updateStartState","granted","onStartShouldSetCapture","handleStart","onStartShouldSet","isGrantedTouch","handleEnd","onRelease","handleMoveCapture","updateMoveState","onMoveShouldSetCapture","handleMove","onMove","onMoveShouldSet","touches","pageX","pageY","s","x_dist","y_dist","delta_x","delta_y","sqrt","len","scaler","terminateCurrentResponder","getCurrentResponder","touchEvents","onTouchStart","onTouchEnd","onTouchMove","onTouchStartCapture","onTouchMoveCapture","mouseEvents","onMouseDown","onMouseDownCapture","bind"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { isMouseEnabled } from \"./mouse-enabled\";\nvar initialState = {\n    time: Date.now(),\n    xy: [0, 0],\n    delta: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    direction: [0, 0],\n    initialDirection: [0, 0],\n    local: [0, 0],\n    lastLocal: [0, 0],\n    velocity: 0,\n    distance: 0\n};\nvar defaultConfig = {\n    enableMouse: true\n};\nvar grantedTouch = null;\nexport function useGestureResponder(options, config) {\n    if (options === void 0) { options = {}; }\n    if (config === void 0) { config = {}; }\n    var state = React.useRef(initialState);\n    var _a = tslib_1.__assign({}, defaultConfig, config), uid = _a.uid, enableMouse = _a.enableMouse;\n    var id = React.useRef(uid || Math.random());\n    var pressed = React.useRef(false);\n    // update our callbacks when they change\n    var callbackRefs = React.useRef(options);\n    React.useEffect(function () {\n        callbackRefs.current = options;\n    }, [options]);\n    /**\n     * Attempt to claim the active touch\n     */\n    function claimTouch(e) {\n        if (grantedTouch && grantedTouch.onTerminationRequest(e)) {\n            grantedTouch.onTerminate(e);\n            grantedTouch = null;\n        }\n        attemptGrant(e);\n    }\n    /**\n     * Attempt to claim the active touch\n     * @param e\n     */\n    function attemptGrant(e) {\n        // if a touch is already active we won't register\n        if (grantedTouch) {\n            return;\n        }\n        grantedTouch = {\n            id: id.current,\n            onTerminate: onTerminate,\n            onTerminationRequest: onTerminationRequest\n        };\n        onGrant(e);\n    }\n    function bindGlobalMouseEvents() {\n        window.addEventListener(\"mousemove\", handleMoveMouse, false);\n        window.addEventListener(\"mousemove\", handleMoveMouseCapture, true);\n        window.addEventListener(\"mouseup\", handleEndMouse);\n    }\n    function unbindGlobalMouseEvents() {\n        window.removeEventListener(\"mousemove\", handleMoveMouse, false);\n        window.removeEventListener(\"mousemove\", handleMoveMouseCapture, true);\n        window.removeEventListener(\"mouseup\", handleEndMouse);\n    }\n    function handleStartCapture(e) {\n        updateStartState(e);\n        pressed.current = true;\n        var granted = onStartShouldSetCapture(e);\n        if (granted) {\n            attemptGrant(e);\n        }\n    }\n    function handleStart(e) {\n        updateStartState(e);\n        pressed.current = true;\n        bindGlobalMouseEvents();\n        var granted = onStartShouldSet(e);\n        if (granted) {\n            attemptGrant(e);\n        }\n    }\n    function isGrantedTouch() {\n        return grantedTouch && grantedTouch.id === id.current;\n    }\n    /**\n     * Handle touchend / mouseup events\n     * @param e\n     */\n    function handleEnd(e) {\n        pressed.current = false;\n        unbindGlobalMouseEvents();\n        if (!isGrantedTouch()) {\n            return;\n        }\n        // remove touch\n        grantedTouch = null;\n        onRelease(e);\n    }\n    /**\n     * Handle touchmove / mousemove capture events\n     * @param e\n     */\n    function handleMoveCapture(e) {\n        updateMoveState(e);\n        if (isGrantedTouch()) {\n            return;\n        }\n        if (onMoveShouldSetCapture(e)) {\n            claimTouch(e);\n        }\n    }\n    /**\n     * Handle touchmove / mousemove events\n     * @param e\n     */\n    function handleMove(e) {\n        if (isGrantedTouch()) {\n            onMove(e);\n            return;\n        }\n        if (onMoveShouldSet(e)) {\n            claimTouch(e);\n        }\n    }\n    /**\n     * When our gesture starts, should we become the responder?\n     */\n    function onStartShouldSet(e) {\n        return callbackRefs.current.onStartShouldSet\n            ? callbackRefs.current.onStartShouldSet(state.current, e)\n            : false;\n    }\n    /**\n     * Same as onStartShouldSet, except using capture.\n     */\n    function onStartShouldSetCapture(e) {\n        return callbackRefs.current.onStartShouldSetCapture\n            ? callbackRefs.current.onStartShouldSetCapture(state.current, e)\n            : false;\n    }\n    /**\n     * When our gesture moves, should we become the responder?\n     */\n    function onMoveShouldSet(e) {\n        return callbackRefs.current.onMoveShouldSet\n            ? callbackRefs.current.onMoveShouldSet(state.current, e)\n            : false;\n    }\n    /**\n     * Same as onMoveShouldSet, but using capture instead\n     * of bubbling.\n     */\n    function onMoveShouldSetCapture(e) {\n        return callbackRefs.current.onMoveShouldSetCapture\n            ? callbackRefs.current.onMoveShouldSetCapture(state.current, e)\n            : false;\n    }\n    /**\n     * The view is responding to gestures. Typically corresponds\n     * with mousedown or touchstart.\n     * @param e\n     */\n    function onGrant(e) {\n        if (callbackRefs.current.onGrant) {\n            callbackRefs.current.onGrant(state.current, e);\n        }\n    }\n    /**\n     * Update our kinematics for start events\n     * @param e\n     */\n    function updateStartState(e) {\n        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;\n        var s = state.current;\n        state.current = tslib_1.__assign({}, initialState, { lastLocal: s.lastLocal || initialState.lastLocal, xy: [pageX, pageY], initial: [pageX, pageY], previous: [pageX, pageY], time: Date.now() });\n    }\n    /**\n     * Update our kinematics when moving\n     * @param e\n     */\n    function updateMoveState(e) {\n        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;\n        var s = state.current;\n        var time = Date.now();\n        var x_dist = pageX - s.xy[0];\n        var y_dist = pageY - s.xy[1];\n        var delta_x = pageX - s.initial[0];\n        var delta_y = pageY - s.initial[1];\n        var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);\n        var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n        var scaler = 1 / (len || 1);\n        var velocity = len / (time - s.time);\n        var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0\n            ? s.initialDirection\n            : [delta_x * scaler, delta_y * scaler];\n        state.current = tslib_1.__assign({}, state.current, { time: time, xy: [pageX, pageY], initialDirection: initialDirection, delta: [delta_x, delta_y], local: [\n                s.lastLocal[0] + pageX - s.initial[0],\n                s.lastLocal[1] + pageY - s.initial[1]\n            ], velocity: time - s.time === 0 ? s.velocity : velocity, distance: distance, direction: [x_dist * scaler, y_dist * scaler], previous: s.xy });\n    }\n    /**\n     * The user is moving their touch / mouse.\n     * @param e\n     */\n    function onMove(e) {\n        if (pressed.current && callbackRefs.current.onMove) {\n            callbackRefs.current.onMove(state.current, e);\n        }\n    }\n    /**\n     * The responder has been released. Typically mouse-up or\n     * touchend events.\n     * @param e\n     */\n    function onRelease(e) {\n        var s = state.current;\n        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });\n        if (callbackRefs.current.onRelease) {\n            callbackRefs.current.onRelease(state.current, e);\n        }\n        grantedTouch = null;\n    }\n    /**\n     * Check with the current responder to see if it can\n     * be terminated. This is currently only triggered when returns true\n     * from onMoveShouldSet. I can't really envision much of a\n     * use-case for doing this with a standard onStartShouldSet.\n     *\n     * By default, returns true.\n     */\n    function onTerminationRequest(e) {\n        return callbackRefs.current.onTerminationRequest\n            ? callbackRefs.current.onTerminationRequest(state.current, e)\n            : true;\n    }\n    /**\n     * The responder has been taken by another view\n     */\n    function onTerminate(e) {\n        var s = state.current;\n        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });\n        if (callbackRefs.current.onTerminate) {\n            callbackRefs.current.onTerminate(state.current, e);\n        }\n    }\n    /**\n     * Use window mousemove events instead of binding to the\n     * element itself to better emulate how touchmove works.\n     */\n    function handleMoveMouse(e) {\n        if (isMouseEnabled()) {\n            handleMove(e);\n        }\n    }\n    function handleMoveMouseCapture(e) {\n        if (isMouseEnabled()) {\n            handleMoveCapture(e);\n        }\n    }\n    function handleEndMouse(e) {\n        if (isMouseEnabled()) {\n            handleEnd(e);\n        }\n    }\n    React.useEffect(function () { return unbindGlobalMouseEvents; }, []);\n    /**\n     * Imperatively terminate the current responder\n     */\n    function terminateCurrentResponder() {\n        if (grantedTouch) {\n            grantedTouch.onTerminate();\n            grantedTouch = null;\n        }\n    }\n    /**\n     * A getter for returning the current\n     * responder, if it exists\n     */\n    function getCurrentResponder() {\n        return grantedTouch;\n    }\n    /**\n     * Required touch / mouse events\n     */\n    var touchEvents = {\n        onTouchStart: handleStart,\n        onTouchEnd: handleEnd,\n        onTouchMove: handleMove,\n        onTouchStartCapture: handleStartCapture,\n        onTouchMoveCapture: handleMoveCapture\n    };\n    var mouseEvents = enableMouse\n        ? {\n            onMouseDown: function (e) {\n                if (isMouseEnabled()) {\n                    handleStart(e);\n                }\n            },\n            onMouseDownCapture: function (e) {\n                if (isMouseEnabled()) {\n                    handleStartCapture(e);\n                }\n            }\n        }\n        : {};\n    return {\n        bind: tslib_1.__assign({}, touchEvents, mouseEvents),\n        terminateCurrentResponder: terminateCurrentResponder,\n        getCurrentResponder: getCurrentResponder\n    };\n}\n"]},"metadata":{},"sourceType":"module"}