{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\n\nvar noop = function () {\n  throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\n\nexport var GridContext = React.createContext({\n  register: noop,\n  remove: noop,\n  getActiveDropId: noop,\n  startTraverse: noop,\n  measureAll: noop,\n  traverse: null,\n  endTraverse: noop,\n  onChange: noop\n});\nexport function GridContextProvider(_a) {\n  var children = _a.children,\n      onChange = _a.onChange;\n\n  var _b = tslib_1.__read(React.useState(null), 2),\n      traverse = _b[0],\n      setTraverse = _b[1];\n\n  var dropRefs = React.useRef(new Map());\n  /**\n   * Register a drop zone with relevant information\n   * @param id\n   * @param options\n   */\n\n  function register(id, options) {\n    dropRefs.current.set(id, options);\n  }\n  /**\n   * Remove a drop zone (typically on unmount)\n   * @param id\n   */\n\n\n  function remove(id) {\n    dropRefs.current.delete(id);\n  }\n  /**\n   * Determine the fixed position (pageX) of an item\n   * @param sourceId\n   * @param rx relative x\n   * @param ry relative y\n   */\n\n\n  function getFixedPosition(sourceId, rx, ry) {\n    var item = dropRefs.current.get(sourceId); // When items are removed from the DOM, the left and top values could be undefined.\n\n    if (!item) {\n      return {\n        x: rx,\n        y: ry\n      };\n    }\n\n    var left = item.left,\n        top = item.top;\n    return {\n      x: left + rx,\n      y: top + ry\n    };\n  }\n  /**\n   * Get a relative position for a target dropzone given\n   * a fixed position\n   * @param targetId\n   * @param fx fixed x\n   * @param fy fixed y\n   */\n\n\n  function getRelativePosition(targetId, fx, fy) {\n    var _a = dropRefs.current.get(targetId),\n        left = _a.left,\n        top = _a.top;\n\n    return {\n      x: fx - left,\n      y: fy - top\n    };\n  }\n  /**\n   * Determine the difference in coordinates between\n   * two dropzones\n   * @param sourceId\n   * @param targetId\n   */\n\n\n  function diffDropzones(sourceId, targetId) {\n    var sBounds = dropRefs.current.get(sourceId);\n    var tBounds = dropRefs.current.get(targetId);\n    return {\n      x: tBounds.left - sBounds.left,\n      y: tBounds.top - sBounds.top\n    };\n  }\n  /**\n   * Determine which dropzone we are actively dragging over\n   * @param sourceId\n   * @param x\n   * @param y\n   */\n\n\n  function getActiveDropId(sourceId, x, y) {\n    var e_1, _a;\n\n    var _b = getFixedPosition(sourceId, x, y),\n        fx = _b.x,\n        fy = _b.y;\n\n    try {\n      // probably faster just using an array for dropRefs\n      for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = tslib_1.__read(_d.value, 2),\n            key = _e[0],\n            bounds = _e[1];\n\n        if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {\n          return key;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Trigger a traversal (when one item is being dropped\n   * on a different dropzone)\n   * @param sourceId\n   * @param targetId\n   * @param x\n   * @param y\n   * @param sourceIndex\n   */\n\n\n  function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n    var _a = getFixedPosition(sourceId, x, y),\n        fx = _a.x,\n        fy = _a.y;\n\n    var _b = getRelativePosition(targetId, fx, fy),\n        rx = _b.x,\n        ry = _b.y;\n\n    var _c = dropRefs.current.get(targetId),\n        targetGrid = _c.grid,\n        count = _c.count;\n\n    var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n\n    var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2),\n        px = _d[0],\n        py = _d[1];\n\n    var _e = diffDropzones(sourceId, targetId),\n        dx = _e.x,\n        dy = _e.y; // only update traverse if targetId or targetIndex have changed\n\n\n    if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {\n      setTraverse({\n        rx: px + dx,\n        ry: py + dy,\n        tx: rx,\n        ty: ry,\n        sourceId: sourceId,\n        targetId: targetId,\n        sourceIndex: sourceIndex,\n        targetIndex: targetIndex\n      });\n    }\n  }\n  /**\n   * End any active traversals\n   */\n\n\n  function endTraverse() {\n    setTraverse(null);\n  }\n  /**\n   * Perform a change to list item arrays.\n   * If it doesn't include targetId, it's a switch\n   * of order within the one array itself.\n   */\n\n\n  function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n    // this is a bit hacky, but seems to work for now. The idea\n    // is that we want our newly mounted traversed grid item\n    // to start its animation from the last target location.\n    // Execute informs our GridDropZone to remove the placeholder\n    // but to pass the initial location to the newly mounted\n    // grid item at the specified index.\n    // The problem here is that it's async, so potentially something\n    // could mount in its place in between setTraversal and onChange\n    // executing. Or maybe onChange won't do anything, in which case\n    // our state is kinda messed up.\n    // So it's sorta a controlled component, but not really, because\n    // if you don't do what we suggest, then it gets messed up.\n    // One solution is to bring the state in-component and force\n    // the state to be updated by us, since it's basically required\n    // anyway.\n    // We could possibly also use a unique identifier for the grid (besides\n    // the index). This could still result in weirdness, but would\n    // be more unlikely.\n    // Ultimately it's kinda messed because we are trying to do something\n    // imperative in a declarative interface.\n    setTraverse(tslib_1.__assign({}, traverse, {\n      execute: true\n    }));\n    onChange(sourceId, sourceIndex, targetIndex, targetId);\n  }\n\n  function measureAll() {\n    dropRefs.current.forEach(function (ref) {\n      ref.remeasure();\n    });\n  }\n\n  return React.createElement(GridContext.Provider, {\n    value: {\n      register: register,\n      remove: remove,\n      getActiveDropId: getActiveDropId,\n      startTraverse: startTraverse,\n      traverse: traverse,\n      measureAll: measureAll,\n      endTraverse: endTraverse,\n      onChange: onSwitch\n    }\n  }, children);\n}","map":{"version":3,"sources":["/Users/sirajmsm/Desktop/gapstarpro/photo-grid-app/FE/node_modules/react-grid-dnd/esm/GridContext.js"],"names":["tslib_1","React","getPositionForIndex","getIndexFromCoordinates","noop","Error","GridContext","createContext","register","remove","getActiveDropId","startTraverse","measureAll","traverse","endTraverse","onChange","GridContextProvider","_a","children","_b","__read","useState","setTraverse","dropRefs","useRef","Map","id","options","current","set","delete","getFixedPosition","sourceId","rx","ry","item","get","x","y","left","top","getRelativePosition","targetId","fx","fy","diffDropzones","sBounds","tBounds","e_1","_c","__values","entries","_d","next","done","_e","value","key","bounds","disableDrop","right","bottom","e_1_1","error","return","call","sourceIndex","targetGrid","grid","count","targetIndex","columnWidth","rowHeight","xy","px","py","dx","dy","tx","ty","onSwitch","__assign","execute","forEach","ref","remeasure","createElement","Provider"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\nvar noop = function () {\n    throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\nexport var GridContext = React.createContext({\n    register: noop,\n    remove: noop,\n    getActiveDropId: noop,\n    startTraverse: noop,\n    measureAll: noop,\n    traverse: null,\n    endTraverse: noop,\n    onChange: noop\n});\nexport function GridContextProvider(_a) {\n    var children = _a.children, onChange = _a.onChange;\n    var _b = tslib_1.__read(React.useState(null), 2), traverse = _b[0], setTraverse = _b[1];\n    var dropRefs = React.useRef(new Map());\n    /**\n     * Register a drop zone with relevant information\n     * @param id\n     * @param options\n     */\n    function register(id, options) {\n        dropRefs.current.set(id, options);\n    }\n    /**\n     * Remove a drop zone (typically on unmount)\n     * @param id\n     */\n    function remove(id) {\n        dropRefs.current.delete(id);\n    }\n    /**\n     * Determine the fixed position (pageX) of an item\n     * @param sourceId\n     * @param rx relative x\n     * @param ry relative y\n     */\n    function getFixedPosition(sourceId, rx, ry) {\n        var item = dropRefs.current.get(sourceId);\n        // When items are removed from the DOM, the left and top values could be undefined.\n        if (!item) {\n            return {\n                x: rx,\n                y: ry\n            };\n        }\n        var left = item.left, top = item.top;\n        return {\n            x: left + rx,\n            y: top + ry\n        };\n    }\n    /**\n     * Get a relative position for a target dropzone given\n     * a fixed position\n     * @param targetId\n     * @param fx fixed x\n     * @param fy fixed y\n     */\n    function getRelativePosition(targetId, fx, fy) {\n        var _a = dropRefs.current.get(targetId), left = _a.left, top = _a.top;\n        return {\n            x: fx - left,\n            y: fy - top\n        };\n    }\n    /**\n     * Determine the difference in coordinates between\n     * two dropzones\n     * @param sourceId\n     * @param targetId\n     */\n    function diffDropzones(sourceId, targetId) {\n        var sBounds = dropRefs.current.get(sourceId);\n        var tBounds = dropRefs.current.get(targetId);\n        return {\n            x: tBounds.left - sBounds.left,\n            y: tBounds.top - sBounds.top\n        };\n    }\n    /**\n     * Determine which dropzone we are actively dragging over\n     * @param sourceId\n     * @param x\n     * @param y\n     */\n    function getActiveDropId(sourceId, x, y) {\n        var e_1, _a;\n        var _b = getFixedPosition(sourceId, x, y), fx = _b.x, fy = _b.y;\n        try {\n            // probably faster just using an array for dropRefs\n            for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var _e = tslib_1.__read(_d.value, 2), key = _e[0], bounds = _e[1];\n                if (!bounds.disableDrop &&\n                    fx > bounds.left &&\n                    fx < bounds.right &&\n                    fy > bounds.top &&\n                    fy < bounds.bottom) {\n                    return key;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return null;\n    }\n    /**\n     * Trigger a traversal (when one item is being dropped\n     * on a different dropzone)\n     * @param sourceId\n     * @param targetId\n     * @param x\n     * @param y\n     * @param sourceIndex\n     */\n    function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n        var _a = getFixedPosition(sourceId, x, y), fx = _a.x, fy = _a.y;\n        var _b = getRelativePosition(targetId, fx, fy), rx = _b.x, ry = _b.y;\n        var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;\n        var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n        var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];\n        var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;\n        // only update traverse if targetId or targetIndex have changed\n        if (!traverse ||\n            !(traverse &&\n                traverse.targetIndex !== targetIndex &&\n                traverse.targetId !== targetId)) {\n            setTraverse({\n                rx: px + dx,\n                ry: py + dy,\n                tx: rx,\n                ty: ry,\n                sourceId: sourceId,\n                targetId: targetId,\n                sourceIndex: sourceIndex,\n                targetIndex: targetIndex\n            });\n        }\n    }\n    /**\n     * End any active traversals\n     */\n    function endTraverse() {\n        setTraverse(null);\n    }\n    /**\n     * Perform a change to list item arrays.\n     * If it doesn't include targetId, it's a switch\n     * of order within the one array itself.\n     */\n    function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n        // this is a bit hacky, but seems to work for now. The idea\n        // is that we want our newly mounted traversed grid item\n        // to start its animation from the last target location.\n        // Execute informs our GridDropZone to remove the placeholder\n        // but to pass the initial location to the newly mounted\n        // grid item at the specified index.\n        // The problem here is that it's async, so potentially something\n        // could mount in its place in between setTraversal and onChange\n        // executing. Or maybe onChange won't do anything, in which case\n        // our state is kinda messed up.\n        // So it's sorta a controlled component, but not really, because\n        // if you don't do what we suggest, then it gets messed up.\n        // One solution is to bring the state in-component and force\n        // the state to be updated by us, since it's basically required\n        // anyway.\n        // We could possibly also use a unique identifier for the grid (besides\n        // the index). This could still result in weirdness, but would\n        // be more unlikely.\n        // Ultimately it's kinda messed because we are trying to do something\n        // imperative in a declarative interface.\n        setTraverse(tslib_1.__assign({}, traverse, { execute: true }));\n        onChange(sourceId, sourceIndex, targetIndex, targetId);\n    }\n    function measureAll() {\n        dropRefs.current.forEach(function (ref) {\n            ref.remeasure();\n        });\n    }\n    return (React.createElement(GridContext.Provider, { value: {\n            register: register,\n            remove: remove,\n            getActiveDropId: getActiveDropId,\n            startTraverse: startTraverse,\n            traverse: traverse,\n            measureAll: measureAll,\n            endTraverse: endTraverse,\n            onChange: onSwitch\n        } }, children));\n}\n"]},"metadata":{},"sourceType":"module"}