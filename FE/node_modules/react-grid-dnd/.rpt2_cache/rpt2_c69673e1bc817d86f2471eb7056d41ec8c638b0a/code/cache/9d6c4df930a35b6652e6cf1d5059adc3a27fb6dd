{"code":"import * as tslib_1 from \"tslib\";\r\n/**\r\n * Get the active drag position given its initial\r\n * coordinates and grid meta\r\n * @param index\r\n * @param grid\r\n * @param dx\r\n * @param dy\r\n */\r\nexport function getDragPosition(index, grid, dx, dy, center) {\r\n    var _a = tslib_1.__read(getPositionForIndex(index, grid).xy, 2), left = _a[0], top = _a[1];\r\n    return {\r\n        xy: [\r\n            left + dx + (center ? grid.columnWidth / 2 : 0),\r\n            top + dy + (center ? grid.rowHeight / 2 : 0)\r\n        ]\r\n    };\r\n}\r\n/**\r\n * Get the relative top, left position for a particular\r\n * index in a grid\r\n * @param i\r\n * @param grid\r\n * @param traverseIndex (destination for traverse)\r\n */\r\nexport function getPositionForIndex(i, _a, traverseIndex) {\r\n    var boxesPerRow = _a.boxesPerRow, rowHeight = _a.rowHeight, columnWidth = _a.columnWidth;\r\n    var index = typeof traverseIndex == \"number\" ? (i >= traverseIndex ? i + 1 : i) : i;\r\n    var x = (index % boxesPerRow) * columnWidth;\r\n    var y = Math.floor(index / boxesPerRow) * rowHeight;\r\n    return {\r\n        xy: [x, y]\r\n    };\r\n}\r\n/**\r\n * Given relative coordinates, determine which index\r\n * we are currently in\r\n * @param x\r\n * @param y\r\n * @param param2\r\n */\r\nexport function getIndexFromCoordinates(x, y, _a, count) {\r\n    var rowHeight = _a.rowHeight, boxesPerRow = _a.boxesPerRow, columnWidth = _a.columnWidth;\r\n    var index = Math.floor(y / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);\r\n    return index >= count ? count : index;\r\n}\r\n/**\r\n * Get the target index during a drag\r\n * @param startIndex\r\n * @param grid\r\n * @param count\r\n * @param dx\r\n * @param dy\r\n */\r\nexport function getTargetIndex(startIndex, grid, count, dx, dy) {\r\n    var _a = tslib_1.__read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2), cx = _a[0], cy = _a[1];\r\n    return getIndexFromCoordinates(cx, cy, grid, count);\r\n}\r\n","dts":{"name":"/Users/benmcmahen/open-source/react-grid-dnd/helpers.d.ts","writeByteOrderMark":false,"text":"import { GridSettings } from \"./grid-types\";\r\n/**\r\n * Get the active drag position given its initial\r\n * coordinates and grid meta\r\n * @param index\r\n * @param grid\r\n * @param dx\r\n * @param dy\r\n */\r\nexport declare function getDragPosition(index: number, grid: GridSettings, dx: number, dy: number, center?: boolean): {\r\n    xy: number[];\r\n};\r\n/**\r\n * Get the relative top, left position for a particular\r\n * index in a grid\r\n * @param i\r\n * @param grid\r\n * @param traverseIndex (destination for traverse)\r\n */\r\nexport declare function getPositionForIndex(i: number, { boxesPerRow, rowHeight, columnWidth }: GridSettings, traverseIndex?: number | false | null): {\r\n    xy: number[];\r\n};\r\n/**\r\n * Given relative coordinates, determine which index\r\n * we are currently in\r\n * @param x\r\n * @param y\r\n * @param param2\r\n */\r\nexport declare function getIndexFromCoordinates(x: number, y: number, { rowHeight, boxesPerRow, columnWidth }: GridSettings, count: number): number;\r\n/**\r\n * Get the target index during a drag\r\n * @param startIndex\r\n * @param grid\r\n * @param count\r\n * @param dx\r\n * @param dy\r\n */\r\nexport declare function getTargetIndex(startIndex: number, grid: GridSettings, count: number, dx: number, dy: number): number;\r\n"}}
