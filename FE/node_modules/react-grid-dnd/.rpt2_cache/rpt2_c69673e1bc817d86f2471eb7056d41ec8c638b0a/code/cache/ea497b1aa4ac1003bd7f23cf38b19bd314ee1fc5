{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as React from \"react\";\r\nimport { useMeasure } from \"./use-measure\";\r\nimport { GridContext } from \"./GridContext\";\r\nimport { swap } from \"./swap\";\r\nimport { getPositionForIndex, getTargetIndex } from \"./helpers\";\r\nimport { GridItemContext } from \"./GridItemContext\";\r\nexport function GridDropZone(_a) {\r\n    var id = _a.id, boxesPerRow = _a.boxesPerRow, children = _a.children, style = _a.style, _b = _a.disableDrag, disableDrag = _b === void 0 ? false : _b, _c = _a.disableDrop, disableDrop = _c === void 0 ? false : _c, rowHeight = _a.rowHeight, other = tslib_1.__rest(_a, [\"id\", \"boxesPerRow\", \"children\", \"style\", \"disableDrag\", \"disableDrop\", \"rowHeight\"]);\r\n    var _d = React.useContext(GridContext), traverse = _d.traverse, startTraverse = _d.startTraverse, endTraverse = _d.endTraverse, register = _d.register, measureAll = _d.measureAll, onChange = _d.onChange, remove = _d.remove, getActiveDropId = _d.getActiveDropId;\r\n    var ref = React.useRef(null);\r\n    var _e = useMeasure(ref), bounds = _e.bounds, remeasure = _e.remeasure;\r\n    var _f = tslib_1.__read(React.useState(null), 2), draggingIndex = _f[0], setDraggingIndex = _f[1];\r\n    var _g = tslib_1.__read(React.useState(null), 2), placeholder = _g[0], setPlaceholder = _g[1];\r\n    var traverseIndex = traverse && !traverse.execute && traverse.targetId === id\r\n        ? traverse.targetIndex\r\n        : null;\r\n    var grid = {\r\n        columnWidth: bounds.width / boxesPerRow,\r\n        boxesPerRow: boxesPerRow,\r\n        rowHeight: rowHeight\r\n    };\r\n    var childCount = React.Children.count(children);\r\n    /**\r\n     * Register our dropzone with our grid context\r\n     */\r\n    React.useEffect(function () {\r\n        register(id, {\r\n            top: bounds.top,\r\n            bottom: bounds.bottom,\r\n            left: bounds.left,\r\n            right: bounds.right,\r\n            width: bounds.width,\r\n            height: bounds.height,\r\n            count: childCount,\r\n            grid: grid,\r\n            disableDrop: disableDrop,\r\n            remeasure: remeasure\r\n        });\r\n    }, [childCount, disableDrop, bounds, id, grid]);\r\n    /**\r\n     * Unregister when unmounting\r\n     */\r\n    React.useEffect(function () {\r\n        return function () { return remove(id); };\r\n    }, [id]);\r\n    // keep an initial list of our item indexes. We use this\r\n    // when animating swap positions on drag events\r\n    var itemsIndexes = React.Children.map(children, function (_, i) { return i; });\r\n    return (React.createElement(\"div\", tslib_1.__assign({ ref: ref, style: tslib_1.__assign({ position: \"relative\" }, style) }, other), grid.columnWidth === 0\r\n        ? null\r\n        : React.Children.map(children, function (child, i) {\r\n            var isTraverseTarget = traverse &&\r\n                traverse.targetId === id &&\r\n                traverse.targetIndex === i;\r\n            var order = placeholder\r\n                ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex)\r\n                : itemsIndexes;\r\n            var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);\r\n            /**\r\n             * Handle a child being dragged\r\n             * @param state\r\n             * @param x\r\n             * @param y\r\n             */\r\n            function onMove(state, x, y) {\r\n                if (!ref.current)\r\n                    return;\r\n                if (draggingIndex !== i) {\r\n                    setDraggingIndex(i);\r\n                }\r\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\r\n                if (targetDropId && targetDropId !== id) {\r\n                    startTraverse(id, targetDropId, x, y, i);\r\n                }\r\n                else {\r\n                    endTraverse();\r\n                }\r\n                var targetIndex = targetDropId !== id\r\n                    ? childCount\r\n                    : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\r\n                if (targetIndex !== i) {\r\n                    if ((placeholder && placeholder.targetIndex !== targetIndex) ||\r\n                        !placeholder) {\r\n                        setPlaceholder({\r\n                            targetIndex: targetIndex,\r\n                            startIndex: i\r\n                        });\r\n                    }\r\n                }\r\n                else if (placeholder) {\r\n                    setPlaceholder(null);\r\n                }\r\n            }\r\n            /**\r\n             * Handle drag end events\r\n             */\r\n            function onEnd(state, x, y) {\r\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\r\n                var targetIndex = targetDropId !== id\r\n                    ? childCount\r\n                    : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);\r\n                // traverse?\r\n                if (traverse) {\r\n                    onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);\r\n                }\r\n                else {\r\n                    onChange(id, i, targetIndex);\r\n                }\r\n                setPlaceholder(null);\r\n                setDraggingIndex(null);\r\n            }\r\n            function onStart() {\r\n                measureAll();\r\n            }\r\n            return (React.createElement(GridItemContext.Provider, { value: {\r\n                    top: pos.xy[1],\r\n                    disableDrag: disableDrag,\r\n                    endTraverse: endTraverse,\r\n                    mountWithTraverseTarget: isTraverseTarget\r\n                        ? [traverse.tx, traverse.ty]\r\n                        : undefined,\r\n                    left: pos.xy[0],\r\n                    i: i,\r\n                    onMove: onMove,\r\n                    onEnd: onEnd,\r\n                    onStart: onStart,\r\n                    grid: grid,\r\n                    dragging: i === draggingIndex\r\n                } }, child));\r\n        })));\r\n}\r\n","dts":{"name":"/Users/benmcmahen/open-source/react-grid-dnd/GridDropZone.d.ts","writeByteOrderMark":false,"text":"import * as React from \"react\";\r\nexport interface GridDropZoneProps extends React.HTMLAttributes<HTMLDivElement> {\r\n    boxesPerRow: number;\r\n    rowHeight: number;\r\n    id: string;\r\n    children: React.ReactNodeArray;\r\n    disableDrag?: boolean;\r\n    disableDrop?: boolean;\r\n    style?: React.CSSProperties;\r\n}\r\nexport declare function GridDropZone({ id, boxesPerRow, children, style, disableDrag, disableDrop, rowHeight, ...other }: GridDropZoneProps): JSX.Element;\r\n"}}
