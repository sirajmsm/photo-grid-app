{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as React from \"react\";\r\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\r\nvar noop = function () {\r\n    throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\r\n};\r\nexport var GridContext = React.createContext({\r\n    register: noop,\r\n    remove: noop,\r\n    getActiveDropId: noop,\r\n    startTraverse: noop,\r\n    measureAll: noop,\r\n    traverse: null,\r\n    endTraverse: noop,\r\n    onChange: noop\r\n});\r\nexport function GridContextProvider(_a) {\r\n    var children = _a.children, onChange = _a.onChange;\r\n    var _b = tslib_1.__read(React.useState(null), 2), traverse = _b[0], setTraverse = _b[1];\r\n    var dropRefs = React.useRef(new Map());\r\n    /**\r\n     * Register a drop zone with relevant information\r\n     * @param id\r\n     * @param options\r\n     */\r\n    function register(id, options) {\r\n        dropRefs.current.set(id, options);\r\n    }\r\n    /**\r\n     * Remove a drop zone (typically on unmount)\r\n     * @param id\r\n     */\r\n    function remove(id) {\r\n        dropRefs.current.delete(id);\r\n    }\r\n    /**\r\n     * Determine the fixed position (pageX) of an item\r\n     * @param sourceId\r\n     * @param rx relative x\r\n     * @param ry relative y\r\n     */\r\n    function getFixedPosition(sourceId, rx, ry) {\r\n        var item = dropRefs.current.get(sourceId);\r\n        // When items are removed from the DOM, the left and top values could be undefined.\r\n        if (!item) {\r\n            return {\r\n                x: rx,\r\n                y: ry\r\n            };\r\n        }\r\n        var left = item.left, top = item.top;\r\n        return {\r\n            x: left + rx,\r\n            y: top + ry\r\n        };\r\n    }\r\n    /**\r\n     * Get a relative position for a target dropzone given\r\n     * a fixed position\r\n     * @param targetId\r\n     * @param fx fixed x\r\n     * @param fy fixed y\r\n     */\r\n    function getRelativePosition(targetId, fx, fy) {\r\n        var _a = dropRefs.current.get(targetId), left = _a.left, top = _a.top;\r\n        return {\r\n            x: fx - left,\r\n            y: fy - top\r\n        };\r\n    }\r\n    /**\r\n     * Determine the difference in coordinates between\r\n     * two dropzones\r\n     * @param sourceId\r\n     * @param targetId\r\n     */\r\n    function diffDropzones(sourceId, targetId) {\r\n        var sBounds = dropRefs.current.get(sourceId);\r\n        var tBounds = dropRefs.current.get(targetId);\r\n        return {\r\n            x: tBounds.left - sBounds.left,\r\n            y: tBounds.top - sBounds.top\r\n        };\r\n    }\r\n    /**\r\n     * Determine which dropzone we are actively dragging over\r\n     * @param sourceId\r\n     * @param x\r\n     * @param y\r\n     */\r\n    function getActiveDropId(sourceId, x, y) {\r\n        var e_1, _a;\r\n        var _b = getFixedPosition(sourceId, x, y), fx = _b.x, fy = _b.y;\r\n        try {\r\n            // probably faster just using an array for dropRefs\r\n            for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var _e = tslib_1.__read(_d.value, 2), key = _e[0], bounds = _e[1];\r\n                if (!bounds.disableDrop &&\r\n                    fx > bounds.left &&\r\n                    fx < bounds.right &&\r\n                    fy > bounds.top &&\r\n                    fy < bounds.bottom) {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Trigger a traversal (when one item is being dropped\r\n     * on a different dropzone)\r\n     * @param sourceId\r\n     * @param targetId\r\n     * @param x\r\n     * @param y\r\n     * @param sourceIndex\r\n     */\r\n    function startTraverse(sourceId, targetId, x, y, sourceIndex) {\r\n        var _a = getFixedPosition(sourceId, x, y), fx = _a.x, fy = _a.y;\r\n        var _b = getRelativePosition(targetId, fx, fy), rx = _b.x, ry = _b.y;\r\n        var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;\r\n        var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\r\n        var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];\r\n        var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;\r\n        // only update traverse if targetId or targetIndex have changed\r\n        if (!traverse ||\r\n            !(traverse &&\r\n                traverse.targetIndex !== targetIndex &&\r\n                traverse.targetId !== targetId)) {\r\n            setTraverse({\r\n                rx: px + dx,\r\n                ry: py + dy,\r\n                tx: rx,\r\n                ty: ry,\r\n                sourceId: sourceId,\r\n                targetId: targetId,\r\n                sourceIndex: sourceIndex,\r\n                targetIndex: targetIndex\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * End any active traversals\r\n     */\r\n    function endTraverse() {\r\n        setTraverse(null);\r\n    }\r\n    /**\r\n     * Perform a change to list item arrays.\r\n     * If it doesn't include targetId, it's a switch\r\n     * of order within the one array itself.\r\n     */\r\n    function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\r\n        // this is a bit hacky, but seems to work for now. The idea\r\n        // is that we want our newly mounted traversed grid item\r\n        // to start its animation from the last target location.\r\n        // Execute informs our GridDropZone to remove the placeholder\r\n        // but to pass the initial location to the newly mounted\r\n        // grid item at the specified index.\r\n        // The problem here is that it's async, so potentially something\r\n        // could mount in its place in between setTraversal and onChange\r\n        // executing. Or maybe onChange won't do anything, in which case\r\n        // our state is kinda messed up.\r\n        // So it's sorta a controlled component, but not really, because\r\n        // if you don't do what we suggest, then it gets messed up.\r\n        // One solution is to bring the state in-component and force\r\n        // the state to be updated by us, since it's basically required\r\n        // anyway.\r\n        // We could possibly also use a unique identifier for the grid (besides\r\n        // the index). This could still result in weirdness, but would\r\n        // be more unlikely.\r\n        // Ultimately it's kinda messed because we are trying to do something\r\n        // imperative in a declarative interface.\r\n        setTraverse(tslib_1.__assign({}, traverse, { execute: true }));\r\n        onChange(sourceId, sourceIndex, targetIndex, targetId);\r\n    }\r\n    function measureAll() {\r\n        dropRefs.current.forEach(function (ref) {\r\n            ref.remeasure();\r\n        });\r\n    }\r\n    return (React.createElement(GridContext.Provider, { value: {\r\n            register: register,\r\n            remove: remove,\r\n            getActiveDropId: getActiveDropId,\r\n            startTraverse: startTraverse,\r\n            traverse: traverse,\r\n            measureAll: measureAll,\r\n            endTraverse: endTraverse,\r\n            onChange: onSwitch\r\n        } }, children));\r\n}\r\n","dts":{"name":"/Users/benmcmahen/open-source/react-grid-dnd/GridContext.d.ts","writeByteOrderMark":false,"text":"import * as React from \"react\";\r\nimport { Bounds } from \"./use-measure\";\r\nimport { GridSettings, TraverseType } from \"./grid-types\";\r\ninterface RegisterOptions extends Bounds {\r\n    /** The number of documents in each grid */\r\n    count: number;\r\n    /** grid info (boxes per row) */\r\n    grid: GridSettings;\r\n    /** whether the dropzone is disabled for dropping */\r\n    disableDrop: boolean;\r\n    remeasure: () => void;\r\n}\r\ninterface GridContextType {\r\n    register: (id: string, options: RegisterOptions) => void;\r\n    remove: (id: string) => void;\r\n    measureAll: () => void;\r\n    getActiveDropId: (sourceId: string, x: number, y: number) => string | null;\r\n    startTraverse: (sourceId: string, targetId: string, x: number, y: number, sourceIndex: number) => void;\r\n    traverse: TraverseType | null;\r\n    endTraverse: () => void;\r\n    onChange: (sourceId: string, sourceIndex: number, targetIndex: number, targetId?: string) => void;\r\n}\r\nexport declare const GridContext: React.Context<GridContextType>;\r\ninterface GridContextProviderProps {\r\n    children: React.ReactNode;\r\n    onChange: (sourceId: string, sourceIndex: number, targetIndex: number, targetId?: string) => void;\r\n}\r\nexport declare function GridContextProvider({ children, onChange }: GridContextProviderProps): JSX.Element;\r\nexport {};\r\n"}}
